Understanding TCP/IP Networking

Networking involves quite a few components that are built atop one another. These include network hardware, data packets, and protocols for data exchange. Together, these components make up a network stack. The most common network stack today is the
Transmission Control Protocol/Internet Protocol (TCP/IP) stack, but this isn’t the only stack available. Nonetheless, understanding the basics of TCP/IP theory will help you configure and manage networks.

Knowing the Basic Functions of Network Hardware

Network hardware is designed to enable two or more computers to communicate with one another. Modern computers have network interfaces built into their motherboards, but internal (PCI, PCIe, or similar) network cards and external (USB, PC Card, and similar) network interfaces are also available. Many networks rely on wires or cables to transmit data between machines as electrical impulses, but network protocols that use radio waves or even light to do the job are growing rapidly in popularity.

Serial Data transfer		* Parallel Data transfer


Investigating Types of Network Hardware

Linux supports several types of common network hardware. The most common is Ethernet, which comes in several varieties. Most Linux servers use twisted-pair cabling, which consists of pairs of wires twisted around each other to minimize interference. Such
varieties of Ethernet are identified by a T suffix to the Ethernet variety name, as in 10BaseT or 100BaseT. The numbers denote the speed of the protocol in megabits per second (Mbps).

In the late 1990s, 100BaseT took over from 10BaseT as the standard in office and even home networks. More recently, 1000BaseT and Ethernet variants that use either wired or optical cabling and that are capable of 1000Mbps speeds (that is, Gigabit Ethernet) have become the standard, with 10 Gigabit Ethernet now available in many server environments.
Other types of network hardware exist, but most are less common than Ethernet. These include Token Ring, LocalTalk, Fiber Distributed Data Interface (FDDI), High- Performance Parallel Interface (HIPPI), and Fiber Channel. Token Ring was common on
some IBM-dominated networks in the 1990s, but it has steadily been losing ground to Ethernet for years. Likewise, LocalTalk was the favored medium for early Macintosh computers, but modern Macs ship with Ethernet instead of LocalTalk. FDDI, HIPPI, and Fibre Channel are all high-speed interfaces that are used in high-performance applications. Some of these protocols support signifi cantly greater maximum cable lengths than does Ethernet, which makes them suitable for linking buildings that are many yards, or even miles, apart. 

In the Linux workstation world, wireless networking (aka Wi-Fi) is an exception to Ethernet’s dominance. Common wireless protocols include 802.11a, 802.11b, 802.11g, and 802.11n. These protocols support maximum speeds of 11Mbps (for 802.11b), 54Mbps (for 802.11a and 802.11g), or 300 Mbps (for 802.11n). With the exception of the rarely used 802.11a, Wi-Fi protocols are compatible with one another, albeit at the speed of the slowest protocol in use. Wireless networking is particularly useful for laptop computers, but it’s even handy for desktop computers in homes and small offices that don’t have adequate wired network infrastructures in place.

In addition to the network hardware in your computers, you need network hardware outside the computers. With the exception of wireless networks, you need some form of network cabling that’s unique to your hardware type. (For 100BaseT Ethernet, get cabling that meets at least Category 5, or Cat-5, specifications. Gigabit Ethernet works best with Cat-5e or optical cables.) Many network types, including twisted-pair Ethernet, require the use of a central device known as a hub or switch. You plug every computer on a local network into this central device, as shown below. The hub or switch then passes data between the computers.

As a general rule, switches are superior to hubs. Hubs mirror all traffic to all computers, whereas switches are smart enough to send packets only to the intended destination. Switches also allow full-duplex transmission, in which both parties can send data at the same time (like two people talking on a telephone). Hubs permit only half-duplex transmission, in which the two computers must take turns (like two people using walkie-talkies).

The result is that switches let two computers engage in full-speed data transfers with each other; with a hub, these two transfers would interfere with each other. Computers with Wi-Fi adapters can be configured to communicate directly with one another, but it’s more common to employ a wireless access point, which links together both wireless and Ethernet devices. Most home network wireless access points also include a router to help connect your home network to a broadband provider, such as cable or DSL, for Internet access.

Understanding Network Packets

Modern networks operate on discrete chunks of data known as packets. Suppose you want to send a 100KiB file from one computer to another. Rather than send the file in one burst of data, your computer breaks it down into smaller chunks. The system might send 100 packets of 1KiB each, for instance. This way, if there’s an error sending one packet, the computer can resend just that one packet rather than the entire file. 

When the recipient system receives packets, it must hold onto them and reassemble them in the correct order to re-create the complete data stream. It’s not uncommon for packets to be delayed or even lost in transmission, so error-recovery procedures are critical for protocols that handle large transfers. Some types of error recovery are handled transparently by the networking hardware.

There are several types of packets, and they can be stored within each other. For instance, Ethernet includes its own packet type (known as a frame), and the packets generated by networking protocols that run atop Ethernet. A data transfer can involve several layers of wrapping and unwrapping data. With each layer, packets from the adjacent layer may be merged or split up.

Understanding Network Protocol Stacks

It’s possible to think of network data at various levels of abstractness. For instance, at one level, a network carries data packets for a specific network type (such as Ethernet); the data packets are addressed to specific computers on a local network. Such a description, while useful for understanding a local network, isn’t very useful for understanding higher-level network protocols, such as those that handle email transfers. These high-level protocols are typically described in terms of commands sent back and forth between computers, frequently without reference to packets. The addresses used at different levels also vary.

A protocol stack is a set of software that converts and encapsulates data between layers of abstraction. For instance, the stack can take the commands of email transfer protocols, and the email messages that are transferred, and package them into packets. Another layer of the stack can take these packets and repackage them into Ethernet frames. There are several layers to any protocol stack, and they interact in highly specified ways. It’s often possible to swap out one component for another at any given layer. For instance, at the top of each stack is a program that uses the stack, such as an email client. You can switch from one email client to another without too much difficulty; both rest atop the same stack. Likewise, if you change a network card, you have to change the driver for that card, which constitutes a layer very low in the stack. Applications above that driver can remain the same.

Each computer in a transaction requires a compatible protocol stack. When they communicate, the computers pass data down their respective stacks and then send data to the partner system, which passes the data up its stack. Each layer on the receiving system sees the data as packaged by its counterpart on the sending computer.

Protocol stacks are frequently represented graphically in diagrams like Figure below , which shows the configuration of the TCP/IP protocol stack that dominates the Internet today. 

As shown in above figure, client programs at the application layer initiate data transfers. These requests pass through the transport, Internet, and link layers on the client computer, whereupon they leave the client system and pass to the server system. On the server, the process reverses itself, with the server program running at the application layer replying to the client program. This reply reverses the journey, traveling down the server computer’s stack, across the network, and up the stack on the client. A full-fledged network connection can involve many backand-forth data transfers.

Each component layer of the sending system is equivalent to a layer on the receiving system, but these layers need not be absolutely identical. For instance, you can have different models of network cards at the link layer, or you can even use entirely different network hardware types, such as Ethernet and Token Ring, if some intervening system translates between them. The computers may run different OSs and hence use different—but logically equivalent—protocol stacks. What’s important is that the stacks operate in compatible ways.

Linux was designed with TCP/IP in mind, and the Internet is built atop TCP/IP. Other protocol stacks are available, though, and you may occasionally run into them. In particular, NetBEUI was the original Microsoft and IBM protocol stack for Windows, AppleTalk was Apple’s initial protocol stack, and Internet Packet Exchange/Sequenced Packet Exchange (IPX/SPX) was Novell’s favored protocol stack. All three are now fading in importance, but you may still need to use them in some environments. Linux supports AppleTalk and IPX/SPX but not NetBEUI.

Knowing TCP/IP Protocol Types

Within TCP/IP, several different protocols exist. Each of these protocols can be classified as falling on one of the four layers of the TCP/IP stack. The most important of the Internet- and transport-layer protocols are the building blocks for the application-layer protocols with which you interact more directly. These important Internet- and transport-layer protocols include the following:

IP The Internet Protocol (IP) is the core protocol in TCP/IP networking. An Internet-layer (aka a network-layer or layer 2) protocol. IP provides a “best effort” method for transferring packets between computers—that is, the packets aren’t guaranteed to reach their destination. Packets may also arrive out of order or corrupted. Other components of the TCP/IP stack must deal with these issues and have their own ways of doing so. IP is also the portion of TCP/IP with which IP addresses are associated.

IPv6 IP version 6, called IPv6, is the update to the original IP stack (often called IPv4). It provides expanded features that help move IP into the next century. For example, IPv4 uses 32-bit addresses, but IPv6 uses 128-bit addresses, providing addresses for up to 3.4 × 1038 devices! IPv6 includes a new feature known as stateless address auto-configuration (SLAAC), which simplifies initial network setup. This feature is similar in some ways to the Dynamic Host Configuration Protocol (DHCP) that’s commonly used on IPv4. A workstation can determine the network address structure and assign itself a unique address
automatically.

ICMP The Internet Control Message Protocol (ICMP) is a simple protocol for communicating data. ICMP is most often used to send error messages between computers—for instance, to signal that a requested service isn’t available. This is often done by modifying an IP packet and returning it to its sender, which means that ICMP is technically an Internet-layer protocol, although it relies upon IP. In most cases, you won’t use programs that generate ICMP packets on demand; they’re created behind the scenes as you use other protocols. One exception is the ping program, which is described in more detail in “Testing Basic Connectivity.”


UDP The User Datagram Protocol (UDP) is the simplest of the common transport-layer (aka layer 3) TCP/IP protocols. It doesn’t provide sophisticated procedures to correct for out-of-order packets, guarantee delivery, or otherwise improve the limitations of IP. This fact can be a problem, but it also means that UDP can be faster than more sophisticated tools that provide such improvements to IP. Common application-layer protocols that are built atop UDP include the Domain Name System (DNS), the Network File System (NFS), and many streaming-media protocols.

TCP The Transmission Control Protocol (TCP) may be the most widely used transport layer protocol in the TCP/IP stack. Unlike UDP, TCP creates full connections with error checking and correction as well as other features. These features simplify the creation of network protocols that must exchange large amounts of data, but the features come at a cost: TCP imposes a small performance penalty. Most of the application-layer protocols with which you may already be familiar, including the Simple Mail Transfer Protocol (SMTP), the Hypertext Transfer Protocol (HTTP), and the File Transfer Protocol (FTP), are built atop TCP.

You may notice that the name of the TCP/IP stack is built up of two of the stack’s protocol names: TCP and IP. This is because these two protocols are so important for TCP/IP networking generally. TCP/IP, though, is much more than just these two protocols;
it includes additional protocols, most of which (below the application layer) are rather obscure. On the other hand, a TCP/IP exchange need not use both TCP and IP—it could be a UDP or ICMP exchange, for instance.

Understanding Network Addressing

In order for one computer to communicate with another over a network, the computers need to have some way to refer to each other. The basic mechanism for doing this is provided by a network address, which can take several different forms, depending on the type of network hardware, protocol stack, and so on. Large and routed networks pose additional challenges to network addressing, and TCP/IP provides answers to these challenges. Finally, to address a specific program on a remote computer, TCP/IP uses a port number, which identifies a specific running program, something like the way a telephone extension number identifies an individual in a large company. 

Using Network Addresses

Consider an Ethernet network. When an Ethernet frame leaves one computer, it’s normally addressed to another Ethernet card. This addressing is done using low-level Ethernet features, independent of the protocol stack in question. A user may have a dial-up telephone connection (through a serial port) but connect to one server that uses Ethernet and another that uses Token Ring. Each of these devices uses a different type of low-level network address. TCP/IP requires something more to integrate across different types of network hardware. In total, three types of addresses are important when you’re trying to understand network addressing: network hardware addresses, numeric IP addresses, and text-based hostnames.


One of the characteristics of dedicated network hardware, such as Ethernet or Token Ring cards, is that they have unique hardware addresses, also known as Media Access Control (MAC) addresses, programmed into them. In the case of Ethernet, these addresses are 6 bytes in length, and they’re generally expressed as hexadecimal (base 16) numbers separated by colons. You can discover the hardware address for an Ethernet card by using the ifconfig command. Type ifconfig ethn, where n is the number of the interface (0 for the first card, 1 for the second, and so on). You’ll see several lines of output, including one like the following:

		eth0 Link encap:Ethernet HWaddr 00:A0:CC:24:BA:02

This line tells you that the device is an Ethernet card and that its hardware address is 00:A0:CC:24:BA:02. What use is this, though? Certain low-level network utilities and hardware use the hardware address. For instance, network switches use it to direct data packets. The switch detects that a particular address is connected to a particular wire, and so it sends data directed at that address only over the associated wire. The Dynamic Host Configuration Protocol (DHCP), is a means of automating the configuration of specific computers. It has an option that uses the hardware address to assign the same IP address consistently to a given computer. In addition, advanced network diagnostic tools are available that let you examine packets that come from or are directed to specific hardware addresses. For the most part, though, you don’t need to be aware of a computer’s hardware address. 

Managing IP Addresses

Earlier, we said that TCP/IP, at least in its IPv4 incarnation, supports about 4 billion addresses. This figure is based on the size of the IP address used in TCP/IP: 4 bytes (32 bits). Specifically, (2)32 = 4,294,967,296. For IPv6, 16-byte (128-bit) addresses are used. Not all of these addresses are usable; some are overhead associated with network definitions, and some are reserved.

The 4-byte IPv4 address and 6-byte Ethernet address are mathematically unrelated. This can be the case for IPv6, too, although the IPv6 standard allows the IPv6 address to be built, in part, from the computer’s MAC address. In any event, the TCP/IP stack converts between the MAC address and the IP address using the Address Resolution Protocol (ARP) for IPv4 or the Neighbor Discovery Protocol (NDP) for IPv6. These protocols enable a computer to send a broadcast query—a message that goes out to all the computers on the local network. This query asks the computer with a given IP address to identify itself. When a reply comes in, it includes the hardware address, so the TCP/IP stack can direct traffic for a given IP address to the target computer’s hardware address.

IPv4 addresses are usually expressed as four base-10 numbers (0–255) separated by periods, as in 172.30.9.102. If your Linux system’s protocol stack is already up and running, you can discover its IP address by using ifconfig, as described earlier. The output includes a line like the following, which identifi es the IP address (inet addr): 

inet addr:172.30.9.102 Bcast:172.30.255.255 Mask:255.255.0.0
Although it isn’t obvious from the IP address alone, this address is broken into two components: a network address and a computer address. The network address identifies a block of IP addresses that are used by one physical network, and the computer address identifies one computer within that network.


IPv6 addresses work in a similar way, except that they’re larger. Specifi cally, IPv6 addresses consist of eight groups of four-digit hexadecimal numbers separated by colons, as in fed1:0db8:85a3:08d3:1319:8a2e:0370:7334. If one or more groups of four digits is 0000, that group or those groups may be omitted, leaving two colons. Only one such group of zeros can be compressed in this way, because if you removed two groups, there would be no way of telling how many sets of zeros would have to be replaced in each group. You can see the IPv6 address assigned to an interface with the inet6 entry in the ifconfig output: 

	inet6 addr: fe80::a00:27ff:fe23:4594/64 Scope:Link

IPv6 uses two types of network addresses—link-local and global. Most Linux distributions automatically assign a link-local IPv6 address to all network interfaces to communicate on the local networks. The fe80:0000:0000:0000: link-local address has become the de facto standard for IPv6 network interfaces.

The Linux system creates a link-local IPv6 network address using this network address along with a combination of the MAC address of the network interface. This ensures that the system will have a unique IPv6 address on the local system, and it can instantly communicate with other IPv6 devices on the local network without any configuration. Link-local addresses are nonroutable; they can only be used for local network connectivity. An IPv6 global address utilizes a network address advertised by a router on the local network so that systems can communicate across network boundaries and out onto the Internet. Either you can statically assign an IPv6 global address or you can use a DHCPv6 server to assign IPv6 global addresses automatically on a network.

Using Network Address

The network mask (also known as the subnet mask or netmask) is a number that identifies the portion of the IP address that’s a network address and the part that’s a computer address. It’s helpful to think of this in binary (base 2) because the netmask uses binary 1 values to represent the network portion of an address and binary 0 values to represent the computer address. The network portion ordinarily leads the computer portion. Expressed in base 10, these addresses usually consist of 255 or 0 values, 255 being a network byte and 0 being a computer byte. If a byte is part network and part computer address, it will have some other value. Following figure illustrates this relationship, using the IP address 172.30.9.102 and the netmask 255.255.0.0.
Another way of expressing a netmask is as a single number representing the number of network bits in the address. This number usually follows the IP address and a slash. For instance, 172.30.9.102/16 is equivalent to 172.30.9.102 with a netmask of 255.255.0.0 the last number shows the network portion to be two solid 8-bit bytes and hence it’s 16 bits. This format is called the Classless Inter-Domain Routing (CIDR) form. The longer notation showing all 4 bytes of the netmask is referred to as dotted quad notation. IPv6 netmasks work just like IPv4 netmasks, except that larger numbers are involved and IPv6 favors hexadecimal over decimal notation.

On modern IPv4 networks, netmasks are often described in CIDR form. Such network masks can be broken at any bit boundary for any address. For instance, 192.168.1.7 could have a netmask of 255.255.0.0, 255.255.255.0, 255.255.255.128, or various other values.

Traditionally, though, IPv4 networks have been broken into one of several classes, as summarized in Table below. Classes A, B, and C are for general networking use. Class D addresses are reserved for multicasting—sending data to multiple computers simultaneously. Class E addresses are reserved for future use. There are a few special cases within most of these ranges. For instance, the 127.x.y.z addresses are reserved for use as loopback (aka localhost) devices—these addresses refer to the computer on which the address is entered. Addresses in which all of the machine bits are set to 1 refer to the network block itself—they’re used for broadcasts. The ultimate broadcast address is 255.255.255.255, which sends data to all computers on a network  segment. 


Within each of the three general-use network classes is a range of addresses reserved for private use. Most IP addresses must be assigned to individual computers by a suitable authority, lest two systems on the Internet both try to use a single address. Anybody can use the reserved private address spaces, though. (These address blocks are sometimes referred to as RFC 1918 addresses, after the standards document—RFC 1918—in which they’re defined.) The caveat is that routers normally drop packets sent to these addresses, effectively isolating them from the Internet as a whole. The idea is that these addresses may be safely used by small private networks. Today, they’re often used behind Network Address Translation (NAT) routers, which enable arbitrary numbers of computers to “hide” behind a single system. The NAT router substitutes its own IP address on outgoing
packets and then directs the reply to the correct system. This is very handy if you want to connect more computers to the Internet than you have IP addresses.

IPv6 has its equivalent to private addresses. Besides link-local address, IPv6 also uses site-local addresses, which may be routed within a site but not off site. They begin with the hexadecimal number fec, fed, fee, or fef. IPv4 address classes were designed to simplify routing, but as the Internet evolved, they became restrictive. Thus, today they serve mainly as a way to set default netmasks, such as 255.0.0.0 for Class A addresses or 255.255.255.0 for Class C addresses. Most configuration tools set these netmasks automatically, but you can override the settings if necessary. IP addresses and netmasks are extremely important for network configuration. If your network doesn’t use DHCP or a similar protocol to assign IP addresses automatically, you must 
configure your system’s IP address manually. A mistake in this configuration can cause a complete failure of networking or more subtle errors, such as an inability to communicate with just some computers.

Broadcasting Data

A broadcast is a type of network transmission that’s sent to all the computers on a local network, or occasionally all of the computers on a remote network. Under TCP/IP, a broadcast is done by specifying binary 1 values in all of the machine bits of the IP address. The network portion of the IP address may be set to the network’s regular value, and this is required for directed broadcasts, that is, those that are sent to a remote network. In many cases, broadcasts are specified by the use of 255.255.255.255 as an IP address. Packets directed at this address are sent to all of the machines on a local network. 

Because the broadcast address for a network is determined by the IP address and netmask, you can convert between the broadcast address and netmask, given one of these and a computer’s IP address. If the netmask happens to consist of whole-byte values (expressed as 0 or 255 in dotted quad notation), the conversion is easy: Replace the IP address components that have 0 values in the dotted quad netmask with 255 values to get the broadcast address. For instance, consider a computer with an IP address of 172.30.9.102 and a netmask of 255.255.0.0. The final two elements of the netmask have 0 values, so you swap in 255 values for these final two elements in the IP address to obtain a broadcast address of 172.30.255.255.

In the case of a CIDR address that has non-255 and non-0 values in the netmask, the situation is more complex because you must resort to binary (base 2) numbers. For instance, consider a computer with an IP address of 172.30.9.102 and a netmask of 255.255.128.0 (that is, 172.30.0.0/17). Expressed in binary, these numbers are 10101100 00011110 00001001 01100110
11111111 11111111 10000000 00000000 To create the broadcast address, you must set the top (network address) values to 1 when the bottom (netmask) value is 0. In this case, the result is 10101100 00011110 01111111 11111111 

Converted back into base 10 notation, the resulting broadcast address is 172.30.127.255. Fortunately, you seldom need to perform such computations. When configuring a computer, you can enter the IP address and netmask and let the computer do the binary computations.

Understanding Hostnames

Computers work with numbers, so it’s not surprising that TCP/IP uses numbers as computer addresses. People, though, work better with names. For this reason, TCP/IP includes a way to link names for computers (known as hostnames) to IP addresses. 

As with IP addresses, hostnames are composed of two parts: machine names and domain names. The former refers to a specific computer and the latter to a collection of computers. Domain names are not equivalent to the network portion of an IP address,
though; they’re completely independent concepts. Domain names are registered for use by an individual or organization, which may assign machine names within the domain and link those machine names to any arbitrary IP address desired. Nonetheless, there is frequently some correspondence between domains and network addresses because an individual or organization that controls a domain is also likely to want a block of IP addresses for the computers in that domain.

Internet domains are structured hierarchically. At the top of the hierarchy are the toplevel domains (TLDs), such as .com, .edu, and .uk. These TLD names appear at the end of an Internet address. Some correspond to nations (such as .uk and .us, for the United
Kingdom and the United States, respectively), but others correspond to particular types of entities (such as .com and .edu, which stand for commercial and educational organizations, respectively). Within each TLD are various domains that identify specific organizations, such as sybex.com for Sybex or loc.gov for the Library of Congress. These organizations may optionally break their domains into subdomains, such as cis.upenn.edu for the Computer and Information Science department at the University of Pennsylvania. Even subdomains may be further subdivided into their own subdomains; this structure can continue for many levels but usually doesn’t. Domains and subdomains include specific computers, such as www.sybex.com, Sybex’s web server.

When you configure your Linux computer, you may need to know its hostname. This will be assigned by your network administrator and will be a machine name within your organization’s domain. If your computer isn’t part of an organizational network you’ll have to make up a hostname. 

Resolving Hostnames

The Domain Name System (DNS) is a distributed database of computers that converts between IP addresses and hostnames. Every domain must maintain at least two DNS servers that can either provide the names for every computer within the domain or redirect
a DNS query to another DNS server that can better handle the request. Therefore, looking up a hostname involves querying a series of DNS servers, each of which redirects the search until the server that’s responsible for the hostname is found. In practice, this process is hidden from you because most organizations maintain DNS servers that do all of the tedious work of chatting with other DNS servers. You need only point your computer to your organization’s DNS servers. This detail may be handled through DHCP, or it may be information that you need to configure manually, as described later in the section “Configuring Linux for a Local Network.” Sometimes, you need to look up DNS information manually. You might do this if you know the IP address of a server through non-DNS means and suspect your DNS configuration is delivering the wrong address or to check whether a DNS server is working.

Several programs can be helpful in performing such checks:

nslookup This program performs DNS lookups (on individual computers by default) and returns the results. It also sports an interactive mode in which you can perform a series of queries. This program is offi cially deprecated, meaning that it’s no longer being maintained and will eventually be dropped from its parent package (bind-utils or bind-tools on most distributions). Thus, you should get in the habit of using host or dig instead of nslookup.

host This program serves as a replacement for the simpler uses of nslookup, but it lacks an interactive mode, and of course many details of its operation differ. In the simplest case, you can type host target.name, where target.name is the hostname or IP address you want to look up. You can add various options that tweak the program’s basic operation; consult host’s man page for details.


dig This program performs more complex DNS lookups than host. Although you can use it to find the IP address for a single hostname (or a hostname for a single IP address), it’s more flexible than host.

whois You can look up information on a domain as a whole with this command. For instance, typing whois sybex.com reveals who owns the sybex.com domain, who to contact in case of problems, and so on. You may want to use this command with -H, which
omits the lengthy legal disclaimers that many domain registries insist on delivering along with whois information. Check the man page for whois for information on additional options.

Network Ports

Contacting a specific computer is important, but one additional type of addressing is left: The sender must have an address for a specific program on the remote system. For instance, suppose you’re using a web browser. The web server computer may be running more servers than just a web server—it may also be running an email server or an FTP server, to name just two of many possibilities. Another number beyond the IP address enables you to direct traffic to a specific program. This number is a  network port number, and programs that access a TCP/IP network typically do so through one or more ports.

When they start up, servers tie themselves to specific ports, which by convention are associated with specific server programs. For instance, port 25 is associated with email servers, and port 80 is used by web servers. The following Table summarizes the purposes of several important ports. A client can direct its request to a specific port and expect to contact an appropriate server. The client’s own port number isn’t fixed; it’s assigned by the OS. Because the client initiates a transfer, it can include its own port number in the connection request, so clients don’t need fixed port numbers. Assigning client port numbers dynamically also enables one computer to run several instances of a single client easily because they won’t compete for access to a single port.